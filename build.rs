use std::env;
use std::fs;
use std::path::Path;
fn main() {
    let project_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    generate_build_config(&project_dir);
    generate_embedded_frontend_assets(&project_dir);

    let src_dir = format!("{}/thirdparty/webui-c-src/src", project_dir);
    let civetweb_dir = format!("{}/civetweb", src_dir);

    let mut build = cc::Build::new();
    build
        .include(format!("{}/thirdparty/webui-c-src/include", project_dir))
        .include(&src_dir)
        .include(&civetweb_dir)
        .warnings(false)
        .flag("-fPIC")
        .flag_if_supported("-w")
        .define("WEBUI_LOG", None)
        .define("USE_CIVETWEB", None)
        .define("NO_SSL", None)
        .define("NO_CACHING", None)
        .define("USE_WEBSOCKET", None)
        .define("USE_IPV6", None);

    build.file(format!("{}/webui.c", src_dir));
    build.file(format!("{}/civetweb/civetweb.c", src_dir));

    build.compile("webui-2-static");

    println!("cargo:rustc-link-search=native=./");
    println!("cargo:rustc-link-lib=webui-2-static");

    let webui_root = format!("{}/thirdparty/webui-c-src", project_dir);
    for entry in walkdir::WalkDir::new(&webui_root) {
        if let Ok(entry) = entry {
            if entry
                .path()
                .extension()
                .is_some_and(|ext| ext == "c" || ext == "h")
            {
                println!("cargo:rerun-if-changed={}", entry.path().display());
            }
        }
    }

    let config_paths = [
        format!("{}/app.config.toml", project_dir),
        format!("{}/config/app.config.toml", project_dir),
    ];
    for config_path in &config_paths {
        if Path::new(config_path).exists() {
            println!("cargo:rerun-if-changed={}", config_path);
        }
    }
}

fn generate_build_config(project_dir: &str) {
    let config_paths = [
        format!("{}/app.config.toml", project_dir),
        format!("{}/config/app.config.toml", project_dir),
    ];

    let mut executable_name = String::from("rustwebui-app");
    let mut package_name = String::from("rustwebui-app");
    let mut log_level = String::from("info");
    let mut log_file = String::from("application.log");

    for config_path in &config_paths {
        if let Ok(content) = fs::read_to_string(config_path) {
            if let Ok(config) = content.parse::<toml::Value>() {
                if let Some(exe_name) = config
                    .get("executable")
                    .and_then(|e| e.get("name"))
                    .and_then(|n| n.as_str())
                {
                    if !exe_name.is_empty() {
                        executable_name = exe_name.to_string();
                    }
                }
                
                if let Some(log) = config.get("logging") {
                    if let Some(level) = log.get("level").and_then(|l| l.as_str()) {
                        log_level = level.to_string();
                    }
                    if let Some(file) = log.get("file").and_then(|f| f.as_str()) {
                        log_file = file.to_string();
                    }
                }
            }
            break;
        }
    }

    if let Ok(name) = env::var("CARGO_PKG_NAME") {
        package_name = name;
    }

    let out_dir = env::var("OUT_DIR").unwrap();
    let build_config_path = format!("{}/build_config.rs", out_dir);

    let build_config = format!(
        r#"// Auto-generated build configuration
// This file is generated by build.rs

pub const PACKAGE_NAME: &str = "{}";
pub const PACKAGE_VERSION: &str = "{}";
pub const EXECUTABLE_NAME: &str = "{}";
pub const DEFAULT_LOG_LEVEL: &str = "{}";
pub const DEFAULT_LOG_FILE: &str = "{}";

pub fn get_executable_name() -> &'static str {{
    EXECUTABLE_NAME
}}

pub fn get_log_level() -> &'static str {{
    DEFAULT_LOG_LEVEL
}}

pub fn get_log_file() -> &'static str {{
    DEFAULT_LOG_FILE
}}
"#,
        package_name,
        env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "1.0.0".to_string()),
        executable_name,
        log_level,
        log_file
    );

    if let Err(e) = fs::write(&build_config_path, build_config) {
        eprintln!("Warning: Failed to write build config: {}", e);
    }
}

fn generate_embedded_frontend_assets(project_dir: &str) {
    let out_dir = env::var("OUT_DIR").unwrap();
    let generated_path = format!("{}/embedded_frontend.rs", out_dir);

    let index_path = format!("{}/dist/index.html", project_dir);
    let main_js_path = format!("{}/dist/static/js/main.js", project_dir);
    let winbox_js_path = format!("{}/dist/static/js/winbox.min.js", project_dir);
    let webui_js_path = format!("{}/dist/static/js/webui.js", project_dir);

    for p in [&index_path, &main_js_path, &winbox_js_path, &webui_js_path] {
        println!("cargo:rerun-if-changed={}", p);
    }

    let index = fs::read_to_string(&index_path).ok();
    let main_js = fs::read_to_string(&main_js_path).ok();
    let winbox_js = fs::read_to_string(&winbox_js_path).ok();
    let webui_js = fs::read_to_string(&webui_js_path).ok();

    let generated = match (index, main_js, winbox_js, webui_js) {
        (Some(index), Some(main_js), Some(winbox_js), Some(webui_js)) => {
            format!(
                r#"// Auto-generated embedded frontend assets
pub const EMBEDDED_FRONTEND_AVAILABLE: bool = true;
pub const EMBEDDED_INDEX_HTML: &str = {};
pub const EMBEDDED_MAIN_JS: &str = {};
pub const EMBEDDED_WINBOX_JS: &str = {};
pub const EMBEDDED_WEBUI_JS: &str = {};
"#,
                format!("{:?}", index),
                format!("{:?}", main_js),
                format!("{:?}", winbox_js),
                format!("{:?}", webui_js),
            )
        }
        _ => {
            r#"// Auto-generated embedded frontend assets
pub const EMBEDDED_FRONTEND_AVAILABLE: bool = false;
pub const EMBEDDED_INDEX_HTML: &str = "";
pub const EMBEDDED_MAIN_JS: &str = "";
pub const EMBEDDED_WINBOX_JS: &str = "";
pub const EMBEDDED_WEBUI_JS: &str = "";
"#
            .to_string()
        }
    };

    if let Err(e) = fs::write(&generated_path, generated) {
        eprintln!("Warning: Failed to write embedded frontend assets: {}", e);
    }
}
